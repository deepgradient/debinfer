---
title: "Bayesian inference for the logistic growth model"
author: "Philipp H Boersch-Supan and Leah R Johnson"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  pdf_document: 
    number_sections: yes
bibliography: debinfer.bib
vignette: >
  %\VignetteIndexEntry{Logistic ODE example}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

#Preliminaries

This examples assumes that `deBInfer` is installed and loaded. If this is not the case it needs to be installed from github, which requires the devtools package.
```{r install1, eval=FALSE}
install.packages("devtools")
```
```{r install1b}
#Load the devtools package.
library(devtools)
```

Then deBInfer can be installed from github.
```{r install2, eval=FALSE, results='hide', message=FALSE, warning=FALSE}
install_github("pboesu/debinfer")
```
```{r loadlib, message=FALSE}
library(deBInfer)
```

#Defining the DE model

We define a logistic growth ODE for deSolve.

```{r ode-def, message=FALSE,warning=FALSE}
library(deSolve)
logistic_model <- function (time, y, parms) {
with(as.list(c(y, parms)), {
dN <- r * N * (1 - N / K)
list(dN)
})
}
y <- c(N = 0.1)
parms <- c(r = 0.1, K = 10)
times <- seq(0, 120, 1)
out <- ode(y, times, logistic_model, parms, method='lsoda')
```

Which gives us the numerical solution

```{r, echo=FALSE}
plot(out)
```

#Simulating observations
Now we simulate a noisy dataset from this equation. We sample a random subset from the integration output 

```{r}
set.seed(143)
N_obs <- as.data.frame(out[c(1,runif(35, 0, nrow(out))),]) #force include the first time-point (t=0)

```
and we "add" lognormal noise 
```{r}
# add lognormal noise
  parms['sdlog.N'] <- 0.05
  N_obs$N_noisy <- rlnorm(nrow(N_obs), log(N_obs$N),parms['sdlog.N'])
#observations must be ordered for solver to work
N_obs <- N_obs[order(N_obs$time),]

plot(N_obs$time, N_obs$N, ylim=c(0, max(N_obs$N,N_obs$N_noisy)))
points(N_obs$time, N_obs$N_noisy, col="red")

out_obs <- ode(y, c(0,N_obs$time), logistic_model, parms, method='lsoda')
plot(out_obs, type="p")
lines(out)
```

#Defining an observation model and parameters for inference
We define an observation model. Note that we are sampling the log of the observation standard deviation, to ensure sampled values are strictly positive.
We also use an epsilon correction for the meanlog, as the DE model can return values of 0 (or even less due to numerical precision). 
```{r obs-model}
  # the observation model
  logistic_obs_model<-function(data, sim.data, samp){

    llik.N<-sum(dlnorm(data$N_noisy, meanlog=log(sim.data[,"N"] + 1e-6), 
                       sdlog=samp[['sdlog.N']], log=TRUE)
                )

    llik<-llik.N

    return(llik)
  }

```

We declare the parameters for inference:
```{r pars, results="hide", message=FALSE}
library(deBInfer)
r <- debinfer_par(name = "r", var.type = "de", fixed = FALSE,
                value = 0.5, prior="norm", hypers=list(mean = 0, sd = 1),
                prop.var=0.005, samp.type="rw")

K <- debinfer_par(name = "K", var.type = "de", fixed = FALSE,
                value = 5, prior="lnorm", hypers=list(meanlog = 1, sdlog = 1),
                prop.var=0.1, samp.type="rw")

sdlog.N <- debinfer_par(name = "sdlog.N", var.type = "obs", fixed = FALSE,
                value = 0.1, prior="lnorm", hypers=list(meanlog = 0, sdlog = 1),
                prop.var=c(3,4), samp.type="rw-unif")
```

and we also need to provide an initial condition for the differential equation:
```{r inits}
N <- debinfer_par(name = "N", var.type = "init", fixed = TRUE, value = 0.1)
```
All declared parameters are collated using the setup_debinfer function
```{r setup}
mcmc.pars <- setup_debinfer(r, K, sdlog.N, N)
```

#Conduct inference
Finally we use deBInfer to estimate the parameters of the original model.
```{r deBinfer, results="hide"}
# do inference with deBInfer
  # MCMC iterations
  iter = 5000
  # inference call
  mcmc_samples <- de_mcmc(N = iter, data=N_obs, de.model=logistic_model, 
                          obs.model=logistic_obs_model, all.params=mcmc.pars,
                          Tmax = max(N_obs$time), data.times=N_obs$time, cnt=iter+1, 
                          plot=FALSE, solver="ode")

```

We plot and summarize the MCMC chains
```{r message=FALSE, warning=FALSE,fig.width = 8, fig.height = 8}
plot(mcmc_samples)
```
From the traceplot we can see that the burnin period is about 200 samples. We can remove the burnin and have a look at parameter correlations, and the overlap between the posterior and prior densities.
```{r}
burnin = 200
pairs(mcmc_samples, burnin = burnin, scatter=TRUE, trend=TRUE)
post_prior_densplot(mcmc_samples, burnin = burnin)
summary(mcmc_samples)
```
We simulate DE model trajectories from the posterior and calculate the HPD interval for the deterministic part of the model.

```{r post-sims}
post_traj <- post_sim(mcmc_samples, n=200, times=0:100, burnin=burnin, output = 'all')
```

We can visualise the median posterior trajectory and the associated highest posterior density interval using `r plot.type="medianHDI"` 
```{r post-sims-plot}
#median and HDI
plot(post_traj, plot.type = "medianHDI")
legend("topleft", legend=c("posterior median", "95% HDI"), lty=1, col=c("red","grey"))

```
Alternatively we can plot an ensemble of posterior trajectories
```{r post-sims-ensemble}
plot(post_traj, plot.type = "ensemble", col = "#FF000040")
```
